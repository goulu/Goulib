from __future__ import division #"true division" everywhere

"""
Friedman numbers and related
"""

__author__ = "Philippe Guglielmetti"
__copyright__ = "Copyright (c) 2017 Philippe Guglielmetti"
__license__ = "LGPL"
__credits__ = ["https://en.wikipedia.org/wiki/Friedman_number"]

__docformat__ = 'restructuredtext'
__version__ = '$Id$'
__revision__ = '$Revision$'

import six 
import logging
from itertools import permutations, product, count
import math
from Goulib import math2, itertools2
from Goulib.expr import Expr

# supported operators with precedence and text + LaTeX repr
# precedence as in https://docs.python.org/2/reference/expressions.html#operator-precedence
#

def concat(left,right):
    if left.isNum and right.isNum and left>0 and right>=0:
        return Expr(str(left)+str(right))
    else:
        return None

def _diadic(left,op,right):
    if op=='+': return left+right
    if op=='-': return left-right
    if op=='*': return left*right
    if op=='/': return left/right
    if op=='^': return left**right
    if op=='**': return left**right
    if op=='_': return concat(left,right)

def _monadic(op,e):
    if op=='': return e
    if op=='+': return e
    if op=='-': return -e
    if op=='s': return Expr(math.sqrt)(e)

def gen(digits,monadic='-', diadic='-+*/^_',permut=True):
    """
    generate all possible Expr using digits and specified operators
    """
    if isinstance(digits,six.integer_types):
        digits=str(digits)
    if isinstance(digits,six.string_types):
        digits=list(digits)
    if permut:
        for d in permutations(digits):
            for x in gen(d,monadic, diadic,False):
                yield x
        return

    if len(digits)==1 or '_' in diadic:
        try:
            e=Expr(''.join(digits))
            if e.isNum: 
                yield e
                for op in monadic:
                    yield _monadic(op,e)
        except:
            pass
        
    for i in range(1,len(digits)):
        try:
            for x in product(
                gen(digits[:i], monadic, diadic, permut),
                diadic,
                gen(digits[i:], monadic, diadic, permut),
            ):
                yield _diadic(*x)
        except:
            pass
            
def friedman(num):
    for e in gen(num):
        try:
            if e()==num and str(e)!=str(num): #concat is too easy ...
                yield (num,e)
        except:
            pass
    
            
def seq(digits,monadic,diadic,permut):
    """
    returns a sequence of Expr generated by gen(**kwargs)
    which evaluate to 0,1,... 
    """
    from Goulib.container import SortedCollection
    from operator import itemgetter
    b=SortedCollection(key=itemgetter(0))
    i=0
    for e in gen(digits,monadic, diadic, permut):
        if e is None: continue
        n=e()
        if n is None: continue
        if type(n) is complex: continue
        if not math2.is_integer(n): continue
        n=math2.rint(n)
        if n<i : continue
        if n>1000000000 : continue
        try:
            b.find(n)
            #already found, skip
        except ValueError:
            b.insert((n,e))
        while b[0][0]==i:
            yield b.pop(0)
            i+=1
    for ne in b:
        yield ne
                        
def yeargame(num):
    return seq(num,'-s','+-*/_',True)
        
def fourfour():
    return seq(4444,'-s','+-*/_',False)
        
if __name__ == "__main__":
    
        
    print('\n4444')
    for e in fourfour():
        print('%d = %s'%e)

                
    print('\nyeargame')
    for e in yeargame(2017):
        print('%d = %s'%e)
                

    print('\nfriedman')
    for x in count(10):
        try:
            e=itertools2.first(friedman(x))
            print('%d = %s'%e)
        except IndexError: # no solution found
            pass   
            
        
        
        
    